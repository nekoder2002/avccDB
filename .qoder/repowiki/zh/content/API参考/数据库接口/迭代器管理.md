# 迭代器管理

<cite>
**本文档引用的文件**   
- [db.go](file://leveldb/db.go)
- [db_iter.go](file://leveldb/db_iter.go)
- [db_snapshot.go](file://leveldb/db_snapshot.go)
- [iterator/iter.go](file://leveldb/iterator/iter.go)
- [util/range.go](file://leveldb/util/range.go)
- [key.go](file://leveldb/key.go)
</cite>

## 目录
1. [简介](#简介)
2. [核心API方法](#核心api方法)
3. [迭代器生命周期管理](#迭代器生命周期管理)
4. [线程安全性和并发使用](#线程安全性和并发使用)
5. [与快照的集成](#与快照的集成)
6. [错误处理和最佳实践](#错误处理和最佳实践)
7. [使用示例](#使用示例)

## 简介
avccDB的迭代器管理功能提供了对数据库键值对进行有序遍历的强大机制。迭代器允许应用程序以高效的方式遍历数据，支持前向和后向遍历、范围查询和前缀查询等操作。本文档详细介绍了`NewIterator`、`NewKeyRangeIterator`和`NewPrefixIterator`等核心方法的使用，以及迭代器的生命周期管理、线程安全性和资源释放机制。

**Section sources**
- [db.go](file://leveldb/db.go#L1219-L1230)
- [iterator/iter.go](file://leveldb/iterator/iter.go#L72-L83)

## 核心API方法
avccDB提供了多种创建迭代器的方法，以满足不同的查询需求。

### NewIterator
`NewIterator`方法创建一个遍历整个数据库或指定范围的迭代器。

```go
func (db *DB) NewIterator(slice *util.Range, ro *opt.ReadOptions) iterator.Iterator
```

**参数说明：**
- `slice *util.Range`：指定遍历的键范围。如果为nil，则遍历整个数据库。`Range`结构包含`Start`和`Limit`两个字段，分别表示范围的起始键（包含）和结束键（不包含）。
- `ro *opt.ReadOptions`：读取选项，用于控制迭代器的行为，如严格模式等。

**返回值：**
- `iterator.Iterator`：返回一个迭代器接口实例，可用于遍历数据库中的键值对。

**Section sources**
- [db.go](file://leveldb/db.go#L1219-L1230)
- [util/range.go](file://leveldb/util/range.go#L9-L16)

### NewKeyRangeIterator
虽然代码中没有直接名为`NewKeyRangeIterator`的方法，但通过`NewIterator`配合`util.Range`可以实现相同的功能。

```go
range := &util.Range{
    Start: []byte("start_key"),
    Limit: []byte("end_key"),
}
iter := db.NewIterator(range, nil)
```

**参数说明：**
- `Start`：范围的起始键，包含在范围内。
- `Limit`：范围的结束键，不包含在范围内。

**使用场景：**
- 当需要遍历特定键范围内的所有键值对时使用。

**Section sources**
- [util/range.go](file://leveldb/util/range.go#L9-L16)
- [db.go](file://leveldb/db.go#L1219-L1230)

### NewPrefixIterator
`NewPrefixIterator`方法用于遍历具有特定前缀的所有键值对。虽然代码中没有直接提供此方法，但可以通过`util.BytesPrefix`函数和`NewIterator`组合实现。

```go
prefix := []byte("prefix")
range := util.BytesPrefix(prefix)
iter := db.NewIterator(range, nil)
```

**参数说明：**
- `prefix []byte`：要匹配的前缀。

**实现原理：**
- `BytesPrefix`函数根据给定的前缀计算出相应的范围。它通过在前缀的最后一个字节上加1来确定范围的结束键。

**使用场景：**
- 当需要遍历具有相同前缀的所有键值对时使用，例如按用户ID前缀查询所有用户数据。

**Section sources**
- [util/range.go](file://leveldb/util/range.go#L18-L32)
- [db.go](file://leveldb/db.go#L1219-L1230)

## 迭代器生命周期管理
正确管理迭代器的生命周期对于避免资源泄漏至关重要。

### 创建和释放
迭代器在创建后必须在使用完毕后显式释放，以释放相关资源。

```go
iter := db.NewIterator(nil, nil)
defer iter.Release() // 确保在函数退出时释放迭代器

// 使用迭代器...
for iter.Next() {
    key := iter.Key()
    value := iter.Value()
    // 处理键值对
}
```

**Release方法：**
- `Release()`：释放迭代器占用的所有资源。调用后，迭代器将不再可用。
- 一旦调用`Release`，任何后续对迭代器的操作都将返回错误。

**自动释放机制：**
- 系统使用`runtime.SetFinalizer`为迭代器设置终结器，确保即使忘记调用`Release`，在垃圾回收时也会自动释放资源。
- 但强烈建议显式调用`Release`，以确保资源及时释放。

**Section sources**
- [db_iter.go](file://leveldb/db_iter.go#L360-L377)
- [db.go](file://leveldb/db.go#L1219-L1230)

### 资源计数
数据库维护了活动迭代器的数量，可以通过`GetProperty`方法查询。

```go
stats, err := db.GetProperty("leveldb.aliveiters")
if err != nil {
    // 处理错误
}
```

**Section sources**
- [db.go](file://leveldb/db.go#L1349-L1350)

## 线程安全性和并发使用
了解迭代器的线程安全性对于正确使用至关重要。

### 并发使用规则
- **单个迭代器**：不是线程安全的，不能在多个goroutine中同时使用。
- **多个迭代器**：可以安全地在多个goroutine中并发使用，每个goroutine使用自己的迭代器实例。

### 推荐的并发模式
```go
// 正确的并发使用方式
var wg sync.WaitGroup
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        iter := db.NewIterator(nil, nil)
        defer iter.Release()
        
        for iter.Next() {
            // 处理数据
        }
    }()
}
wg.Wait()
```

**Section sources**
- [iterator/iter.go](file://leveldb/iterator/iter.go#L78-L82)

## 与快照的集成
迭代器可以与快照结合使用，以确保遍历过程中数据的一致性。

### 从快照创建迭代器
```go
snapshot, err := db.GetSnapshot()
if err != nil {
    // 处理错误
}
defer snapshot.Release()

iter := snapshot.NewIterator(nil, nil)
defer iter.Release()

// 遍历快照中的数据
for iter.Next() {
    key := iter.Key()
    value := iter.Value()
    // 处理键值对
}
```

### 快照迭代器的特点
- **一致性**：快照迭代器保证遍历的是创建快照时的数据库状态，即使数据库在遍历过程中被修改。
- **独立性**：快照迭代器的释放不影响快照本身的生命周期，快照需要单独释放。
- **资源管理**：快照迭代器创建时会获取快照的引用，但不会增加快照的引用计数。

**Section sources**
- [db_snapshot.go](file://leveldb/db_snapshot.go#L154-L166)
- [db_snapshot.go](file://leveldb/db_snapshot.go#L168-L186)

## 错误处理和最佳实践
正确的错误处理是确保应用程序稳定性的关键。

### 常见错误类型
- `ErrIterReleased`：在已释放的迭代器上调用方法。
- `ErrSnapshotReleased`：在已释放的快照上创建迭代器。
- 其他底层存储错误。

### 错误处理最佳实践
```go
iter := db.NewIterator(nil, nil)
defer iter.Release()

for iter.Next() {
    if err := iter.Error(); err != nil {
        // 处理迭代过程中的错误
        log.Printf("迭代器错误: %v", err)
        break
    }
    
    key := iter.Key()
    value := iter.Value()
    // 处理键值对
}

// 检查最终状态
if err := iter.Error(); err != nil {
    log.Printf("迭代完成时发生错误: %v", err)
}
```

### 防止资源泄漏
- 始终使用`defer iter.Release()`确保迭代器被释放。
- 避免在循环中创建大量迭代器而不释放。
- 定期检查`leveldb.aliveiters`属性，监控活动迭代器数量。

**Section sources**
- [db_iter.go](file://leveldb/db_iter.go#L390-L392)
- [db_iter.go](file://leveldb/db_iter.go#L143-L147)

## 使用示例
以下是一些常见的迭代器使用模式。

### 数据遍历
```go
iter := db.NewIterator(nil, nil)
defer iter.Release()

for iter.Next() {
    key := iter.Key()
    value := iter.Value()
    fmt.Printf("键: %s, 值: %s\n", key, value)
}

if err := iter.Error(); err != nil {
    log.Printf("遍历错误: %v", err)
}
```

### 范围查询
```go
range := &util.Range{
    Start: []byte("user_100"),
    Limit: []byte("user_200"),
}
iter := db.NewIterator(range, nil)
defer iter.Release()

for iter.Next() {
    key := iter.Key()
    value := iter.Value()
    fmt.Printf("用户数据: %s -> %s\n", key, value)
}
```

### 前缀查询
```go
prefix := []byte("session_")
range := util.BytesPrefix(prefix)
iter := db.NewIterator(range, nil)
defer iter.Release()

for iter.Next() {
    key := iter.Key()
    value := iter.Value()
    fmt.Printf("会话数据: %s -> %s\n", key, value)
}
```

### 反向遍历
```go
iter := db.NewIterator(nil, nil)
defer iter.Release()

if iter.Last() {
    do {
        key := iter.Key()
        value := iter.Value()
        fmt.Printf("键: %s, 值: %s\n", key, value)
    } for iter.Prev()
}

if err := iter.Error(); err != nil {
    log.Printf("反向遍历错误: %v", err)
}
```

**Section sources**
- [db.go](file://leveldb/db.go#L1219-L1230)
- [util/range.go](file://leveldb/util/range.go#L18-L32)
- [db_iter.go](file://leveldb/db_iter.go#L154-L167)
- [db_iter.go](file://leveldb/db_iter.go#L306-L344)