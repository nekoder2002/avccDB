# 数据合并过程

<cite>
**本文引用的文件列表**
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go)
- [leveldb/key.go](file://leveldb/key.go)
- [leveldb/db_test.go](file://leveldb/db_test.go)
</cite>

## 目录
1. [引言](#引言)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构总览](#架构总览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考量](#性能考量)
8. [故障排查指南](#故障排查指南)
9. [结论](#结论)
10. [附录](#附录)

## 引言
本文件围绕 avccDB 的数据合并过程，系统性阐述 tableCompactionBuilder 如何借助合并迭代器（merged_iter）将多个 SSTable 文件的数据有序合并为新的输出文件。重点覆盖以下主题：
- 合并迭代器如何在多路输入上按内部键序进行归并遍历；
- 在合并过程中如何处理相同键的不同版本、删除标记（keyTypeDel）与序列号（seq）的比较规则；
- trivial 判断逻辑如何识别可直接移动的单个文件以提升性能；
- 非平凡压缩中逐条处理键值对的流程；
- 基于 TestDB_TableCompactionBuilder 测试用例，说明重复键、过期数据的处理策略；
- 提供从多个输入文件到单一输出文件的数据流图。

## 项目结构
与数据合并直接相关的模块包括：
- 合并调度与执行：tableCompaction、tableCompactionBuilder
- 合并迭代器：NewMergedIterator 及其内部堆实现
- 键编码与解析：internalKey 编解码、序列号与类型字段
- 合并策略与范围选择：compaction 的 trivial 判定、shouldStopBefore、baseLevelForKey 等

```mermaid
graph TB
subgraph "合并调度层"
TC["tableCompaction<br/>选择与提交"]
TCB["tableCompactionBuilder<br/>构建输出表"]
end
subgraph "迭代层"
CI["compaction.newIterator()<br/>构造多路迭代器"]
MI["merged_iter.NewMergedIterator<br/>多路归并堆"]
end
subgraph "键模型"
IK["internalKey<br/>ukey/seq/kt 解析"]
end
subgraph "存储层"
ST["SSTable 文件集合"]
end
TC --> TCB
TC --> CI
CI --> MI
MI --> IK
ST --> CI
IK --> TCB
TCB --> ST
```

图表来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/key.go](file://leveldb/key.go#L106-L146)

章节来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L248-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/key.go](file://leveldb/key.go#L106-L146)

## 核心组件
- tableCompaction：负责挑选待合并的输入集、计算最小序列号、调用 tableCompactionBuilder 构建输出、提交事务。
- tableCompactionBuilder：逐条消费合并迭代器输出，按规则丢弃过期版本或删除标记，写入新表文件。
- compaction.newIterator：根据输入层级构造多路迭代器，必要时使用 NewMergedIterator 进行归并。
- merged_iter：基于堆的多路归并，保证按比较器顺序返回键值对。
- internalKey：包含用户键、版本号、序列号与类型字段，用于排序与语义判定。

章节来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/key.go](file://leveldb/key.go#L106-L146)

## 架构总览
下图展示了从输入文件到输出文件的端到端流程，包括 trivial 移动与非平凡压缩两条路径。

```mermaid
sequenceDiagram
participant DB as "DB"
participant TC as "tableCompaction"
participant C as "compaction"
participant IT as "newIterator()"
participant MI as "MergedIterator"
participant B as "tableCompactionBuilder"
participant OUT as "输出表文件"
DB->>TC : 触发合并
TC->>C : 选择输入集/计算最小序列号
alt trivial 可行
TC->>OUT : 直接移动单文件
TC-->>DB : 提交记录
else 非平凡压缩
TC->>IT : 构造多路迭代器
IT->>MI : 归并堆
MI-->>B : 按序返回键值对
loop 遍历每个键
B->>B : 解析内部键/版本/序列号
B->>B : 判定是否丢弃/保留
B->>OUT : 写入有效键值
end
B-->>TC : 完成输出
TC->>DB : 提交记录
end
```

图表来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)

## 详细组件分析

### 合并迭代器（merged_iter）工作原理
- 多路输入：当源层级为 0 时，可能有多份重叠文件；当源层级 > 0 时，使用索引迭代器聚合。
- 归并堆：以比较器 Compare 为依据，维护一个最小堆，每次弹出当前最小键对应的迭代器索引。
- 方向控制：支持 First/Last/Next/Prev，内部通过堆与方向状态机驱动。
- 错误处理：strict 模式下遇到损坏错误会终止；否则跳过该输入迭代器继续。

```mermaid
flowchart TD
Start(["初始化堆"]) --> Push["将各路首个键入堆"]
Push --> Loop{"堆非空？"}
Loop --> |是| Pop["弹出最小键索引"]
Pop --> Yield["返回该键值对"]
Yield --> Advance["推进对应路的迭代器"]
Advance --> Update{"该路仍有键？"}
Update --> |是| RePush["将新键入堆"]
Update --> |否| Skip["该路结束"]
RePush --> Loop
Skip --> Loop
Loop --> |否| End(["结束"])
```

图表来源
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L145-L245)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)

章节来源
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L145-L245)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)

### tableCompactionBuilder 的合并处理逻辑
- 输入来源：通过 compaction.newIterator 获取统一有序的键序列。
- 关键状态：
  - lastUkey：最近处理的用户键
  - lastSeq：当前用户键保留的最高序列号
  - dropCnt/kerrCnt：丢弃计数与键错误计数
- 版本与删除处理：
  - 当 lastSeq <= minSeq 且为版本化键时，保留所有历史版本（mLSM 要求）。
  - 对于非版本化键，若存在更新版本则丢弃旧版本（dropCnt++）。
  - 删除标记（keyTypeDel）在特定条件下（如位于基底层级）被保留以支撑 Merkle 证明。
- 表大小与快照：
  - 当前表达到阈值或需要停止时 flush 输出新表，并保存快照以便可恢复。
- 最终清理：若发生错误，清理未完成的输出表。

```mermaid
flowchart TD
S(["开始"]) --> Read["读取下一个内部键"]
Read --> Parse["解析 ukey/seq/kt"]
Parse --> Err{"解析错误？"}
Err --> |是| Strict{"strict 模式？"}
Strict --> |是| Fail["返回错误"]
Strict --> |否| Reset["重置状态并继续"]
Err --> |否| SameUkey{"与 lastUkey 相同？"}
SameUkey --> |否| Rotate{"需旋转/flush 或达到阈值？"}
Rotate --> |是| Flush["flush 并保存快照"]
Rotate --> |否| Keep["保持状态"]
SameUkey --> |是| Check["检查版本/删除规则"]
Check --> Drop{"应丢弃？"}
Drop --> |是| Count["增加 dropCnt 并跳过"]
Drop --> |否| Keep
Keep --> Append["写入输出表"]
Append --> Next["继续"]
Count --> Next
Next --> Read
Fail --> E(["结束"])
Reset --> Read
Flush --> Read
```

图表来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L432-L555)

章节来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L432-L555)

### trivial 判定与优化
- trivial 条件：仅输入一层的一个文件，且其与“曾祖父级”（grandparent）重叠不超过阈值。
- 作用：避免不必要的重排序与写放大，直接将该文件移动到下一层。

```mermaid
flowchart TD
A["输入文件集"] --> B{"仅一层且仅一个文件？"}
B --> |否| C["非 trivial，进入非平凡压缩"]
B --> |是| D{"与 GP 重叠<=阈值？"}
D --> |否| C
D --> |是| E["trivial：直接移动文件"]
```

图表来源
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L248-L251)
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L580)

章节来源
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L248-L251)
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L580)

### 非平凡压缩中的逐条处理
- 构造多路迭代器：对于层级 0 使用逐文件迭代器，其他层级使用索引迭代器聚合后归并。
- 归并顺序：由比较器决定，确保全局有序。
- 写入策略：遵循版本与删除规则，丢弃过期项，必要时保留删除标记。

```mermaid
sequenceDiagram
participant C as "compaction"
participant IT as "newIterator()"
participant MI as "MergedIterator"
participant B as "tableCompactionBuilder"
C->>IT : 构造输入迭代器切片
IT->>MI : NewMergedIterator(比较器, strict)
MI-->>B : 按序返回键值对
loop 遍历
B->>B : 解析内部键/版本/删除
B->>B : 决策保留/丢弃
B->>B : 写入输出表
end
```

图表来源
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L432-L555)

章节来源
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L432-L555)

### 键编码、序列号与删除标记规则
- internalKey 结构：用户键 + 序列号+类型字段（低 8 位），用于排序与语义判定。
- 排序规则：比较器按用户键排序；当用户键相同时，序列号越大越靠前（降序）。
- 删除标记（keyTypeDel）：当键类型为删除标记时，表示该键已被删除；在某些场景（如基底层级）会被保留以维持一致性证明。
- 版本化键：带版本号的内部键在解析时区分处理，允许保留历史版本以满足 mLSM 的历史状态验证需求。

章节来源
- [leveldb/key.go](file://leveldb/key.go#L106-L146)
- [leveldb/key.go](file://leveldb/key.go#L162-L196)
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L502-L528)

### 基于 TestDB_TableCompactionBuilder 的策略验证
- 重复键与多版本：测试通过在单表中写入同一用户键的多个版本，验证合并后仍能正确保留所需版本。
- 过期数据：通过设置最小序列号与 strict 模式，验证过期版本被丢弃，删除标记在基底层级被保留。
- 错误模拟：通过存储层模拟随机 IO 错误，验证可恢复事务机制与回滚行为。

章节来源
- [leveldb/db_test.go](file://leveldb/db_test.go#L2583-L2763)

## 依赖关系分析
- tableCompactionBuilder 依赖 compaction.newIterator 提供统一有序输入。
- compaction.newIterator 依赖 merged_iter.NewMergedIterator 实现多路归并。
- internalKey 的解析与比较贯穿整个合并流程，决定版本保留与删除策略。
- trivial 判定与 shouldStopBefore/baseLevelForKey 共同影响输入集扩展与输出分隔。

```mermaid
graph LR
DB["db_compaction.go"] --> C["session_compaction.go"]
C --> MI["merged_iter.go"]
C --> IK["key.go"]
DB --> IK
DB --> MI
```

图表来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/key.go](file://leveldb/key.go#L106-L146)

章节来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
- [leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
- [leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
- [leveldb/key.go](file://leveldb/key.go#L106-L146)

## 性能考量
- trivial 移动：避免不必要的重排序与写放大，显著降低 I/O 与 CPU 开销。
- 表大小阈值：当当前输出表达到阈值时 flush，平衡内存占用与写放大。
- 多路归并：堆的插入/弹出复杂度为 O(log k)，k 为输入路数，整体近似线性遍历。
- 严格模式：strict=true 时遇到损坏键会立即失败，减少无效重试；strict=false 时可跳过损坏输入继续。

## 故障排查指南
- 合并失败：检查 compactionTransact 是否捕获并回滚；查看 kerrCnt 与 dropCnt 统计。
- 键解析错误：确认 internalKey 长度与类型字段合法；strict 模式下错误将导致提前退出。
- 删除标记丢失：核对 baseLevelForKey 与 shouldStopBefore 的判定逻辑，确保基底层级删除标记被保留。
- IO 错误：利用存储层模拟错误能力定位问题点，观察可恢复重试与回滚行为。

章节来源
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L147-L210)
- [leveldb/db_compaction.go](file://leveldb/db_compaction.go#L432-L555)
- [leveldb/db_test.go](file://leveldb/db_test.go#L2706-L2763)

## 结论
avccDB 的数据合并通过 tableCompactionBuilder 与合并迭代器协同工作，实现了高效、可控的多输入有序合并。trivial 判定在多数情况下避免了不必要的重排序，而非平凡压缩则通过严格的版本与删除规则保障数据一致性与历史状态可验证性。测试用例进一步验证了重复键、过期数据与错误处理等关键行为。

## 附录
- 关键流程参考路径
  - 合并调度与提交：[leveldb/db_compaction.go](file://leveldb/db_compaction.go#L567-L629)
  - 合并迭代器构造：[leveldb/session_compaction.go](file://leveldb/session_compaction.go#L292-L330)
  - 合并迭代器实现：[leveldb/iterator/merged_iter.go](file://leveldb/iterator/merged_iter.go#L299-L317)
  - 键解析与排序：[leveldb/key.go](file://leveldb/key.go#L106-L146)
  - 测试用例验证：[leveldb/db_test.go](file://leveldb/db_test.go#L2583-L2763)